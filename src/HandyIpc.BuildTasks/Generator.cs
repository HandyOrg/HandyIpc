using System.Collections.Generic;
using System.IO;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace HandyIpc.BuildTasks
{
    public class Generator
    {
        public static TemplateData GetTemplateData(IEnumerable<string> filePaths)
        {
            var validInterfaces = filePaths
                .Select(x => CSharpSyntaxTree.ParseText(File.ReadAllText(x)))
                .SelectMany(FindValidInterfaces)
                .OrderBy(i => i.Identifier.Text)
                .ToList();

            var usingList = validInterfaces
                .SelectMany(@interface => @interface
                    .GetSyntaxNodeRoot<SyntaxNode>()
                    .DescendantNodes()
                    .OfType<UsingDirectiveSyntax>()
                    .Select(x => $"{x.Alias} {x.StaticKeyword} {x.Name}".TrimStart()))
                .Distinct()
                .Where(item => item != "HandyIpc")
                .ToList();

            var classList = validInterfaces.Select(GetClassData).ToList();

            return new TemplateData
            {
                UsingList = usingList,
                ClassList = classList
            };
        }

        private static ClassData GetClassData(InterfaceDeclarationSyntax @interface)
        {
            // ReSharper disable once UseObjectOrCollectionInitializer
            var result = new ClassData();

            result.InterfaceName = @interface.GetInterfaceName();
            result.GeneratedClassSuffix = result.InterfaceName.Replace(".", string.Empty);
            result.Modifiers = @interface.Modifiers
                .Select(item => item.ValueText)
                .FirstOrDefault(item => item == "public" || item == "internal");
            //result.BaseClasses = @interface.BaseList?.Types.Select(b => b.GetSimpleName()).Where(b => b != null)
            //    .Select(t => new BaseClassInfo
            //    {
            //        Name = t.Identifier.ValueText,
            //        TypeParametersInfo = (t is GenericNameSyntax g ? g.TypeArgumentList.Arguments.Select(a => a.GetTypeInfo()).ToList() : null)
            //    }).ToList();
            var parent = @interface.GetSyntaxNodeRoot<NamespaceDeclarationSyntax>();
            result.Namespace = parent?.Name?.ToString() ?? $"AutoGenerated{result.GeneratedClassSuffix}";

            if (@interface.TypeParameterList != null)
            {
                var typeParameters = @interface.TypeParameterList.Parameters;
                if (typeParameters.Any())
                {
                    result.TypeParameters = typeParameters.Select(item => item.Identifier.ValueText).ToListString();
                }

                result.ConstraintClauses = @interface.ConstraintClauses.ToFullString().Trim();
            }

            result.MethodList = @interface.Members
                .OfType<MethodDeclarationSyntax>()
                .Select(GetMethodData)
                .ToList();

            return result;
        }

        private static MethodData GetMethodData(MethodDeclarationSyntax method)
        {
            var result = new MethodData
            {
                Name = method.Identifier.Text,
                ReturnType = method.ReturnType.ToTypeData().ToTypeString(),
            };

            // Resolve args list
            var arguments = method.ParameterList.Parameters
                .Select(item => (name: item.Identifier.Text, type: item.Type.ToTypeData()))
                .ToList();
            result.Parameters = arguments.Select(item => item.name).ToListString();
            result.ParameterTypes = arguments.Select(item => item.type.ToTypeString()).ToListString();
            result.TypeAndParameters = arguments
                .Select(item => $"{item.type.ToTypeString()} {item.name}")
                .ToListString();
            result.Arguments = arguments
                .Select((item, i) => $"args[{i}].CastTo<{item.type.ToTypeString()}>()")
                .ToListString();

            // Resolve return type
            result.IsVoid = result.ReturnType == "void";
            if (result.ReturnType == "Task")
            {
                result.IsVoid = true;
                result.IsAwaitable = true;
            }

            if (method.ReturnType is GenericNameSyntax genericName &&
                genericName.Identifier.ValueText == "Task")
            {
                result.IsAwaitable = true;
                result.TaskReturnType = method.ReturnType.ToTypeData().Children.Single().ToTypeString();
            }

            return result;
        }

        private static IEnumerable<InterfaceDeclarationSyntax> FindValidInterfaces(SyntaxTree tree)
        {
            var nodes = tree.GetRoot().DescendantNodes().ToList();

            return nodes.OfType<InterfaceDeclarationSyntax>()
                .Where(@interface => @interface.AttributeLists
                    .Any(attributeList => attributeList.Attributes
                        .Any(attribute =>
                        {
                            var attributeName = attribute.Name.ToFullString();
                            return attributeName == "IpcContract" || attributeName == "HandyIpc.IpcContract";
                        })))
                .Where(@interface => @interface.Members.OfType<MethodDeclarationSyntax>().Any());
        }
    }

    public static class Extensions
    {
        public static string GetInterfaceName(this InterfaceDeclarationSyntax @interface)
        {
            var identifier = @interface.Identifier;
            var interfaceParent = identifier.Parent != null ? identifier.Parent.Parent : identifier.Parent;

            if ((interfaceParent as ClassDeclarationSyntax) != null)
            {
                var classParent = (interfaceParent as ClassDeclarationSyntax).Identifier;
                return classParent + "." + identifier.ValueText;
            }

            return identifier.ValueText;
        }

        public static T GetSyntaxNodeRoot<T>(this SyntaxNode node) where T : SyntaxNode
        {
            var root = node;
            while (root.Parent is T)
            {
                root = root.Parent;
            }

            return root as T;
        }

        public static TypeData ToTypeData(this TypeSyntax typeSyntax)
        {
            return typeSyntax is GenericNameSyntax generic
                ? new TypeData
                {
                    Name = generic.Identifier.ValueText,
                    Children = generic.TypeArgumentList.Arguments.Select(a => a.ToTypeData()).ToList()
                }
                : new TypeData { Name = typeSyntax.ToString() };
        }

        public static string ToTypeString(this TypeData typeData)
        {
            return typeData.Name + (typeData.Children?.Count > 0
                       ? $"<{typeData.Children.Select(item => item.ToTypeString()).ToListString()}>"
                       : string.Empty);
        }

        public static string ToListString(this IEnumerable<string> items)
        {
            return string.Join(", ", items);
        }
    }
}
