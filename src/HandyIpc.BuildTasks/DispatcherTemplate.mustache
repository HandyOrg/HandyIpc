using System;
using HandyIpc;
using HandyIpc.Server;

{{#ClassList}}
namespace {{Namespace}}
{
{{#UsingList}}
using {{.}};
{{/UsingList}}
{{#HasGenericMethod}}
using System.Collections.Generic;
using System.Reflection;
{{/HasGenericMethod}}

    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [global::System.Diagnostics.DebuggerNonUserCode]
    [global::System.Reflection.Obfuscation(Exclude = true)]
    public class AutoGeneratedServer{{GeneratedClassSuffix}}{{#TypeParameters}}<{{.}}>{{/TypeParameters}} : IIpcDispatcher
        {{ConstraintClauses}}
    {
        private readonly {{InterfaceName}}{{#TypeParameters}}<{{.}}>{{/TypeParameters}} _instance;
{{#HasGenericMethod}}
        private readonly Lazy<IReadOnlyDictionary<string, MethodInfo>> _genericMethodMapping;
{{/HasGenericMethod}}

        public AutoGeneratedServer{{GeneratedClassSuffix}}({{InterfaceName}}{{#TypeParameters}}<{{.}}>{{/TypeParameters}} instance)
        {
            _instance = instance;
{{#HasGenericMethod}}
            _genericMethodMapping = new Lazy<IReadOnlyDictionary<string, MethodInfo>>(
                () => _instance.GetGenericMethodMapping(typeof({{InterfaceName}}{{#TypeParameters}}<{{.}}>{{/TypeParameters}})));
{{/HasGenericMethod}}
        }

        public async Task Dispatch(Context context, Func<Task> next)
        {
            var request = context.Get<Request>();
            var args = request.Arguments;

            object result;
            switch (request.MethodName)
            {
{{#MethodList}}
                {{#MethodTypeParameters}}
                case "{{Name}}<{{.}}>({{ParameterTypes}})"
                when (_genericMethodMapping.Value.TryGetValue("{{Name}}<{{.}}>({{ParameterTypes}})", out var methodInfo)):
                {
                    var obj = methodInfo.MakeGenericMethod(request.MethodGenericArguments)
                        .Invoke(_instance, request.Arguments);
                    {{#IsVoid}}
                    {{#IsAwaitable}}await (Task)obj;{{/IsAwaitable}}
                    result = DataConstants.Unit;
                    {{/IsVoid}}
                    {{^IsVoid}}
                    result = {{#IsAwaitable}}await {{/IsAwaitable}}({{ReturnType}})obj;
                    {{/IsVoid}}
                    break;
                }
                {{/MethodTypeParameters}}
                {{^MethodTypeParameters}}
                case "{{Name}}({{ParameterTypes}})":
                    {{#IsVoid}}
                    {{#IsAwaitable}}await {{/IsAwaitable}}_instance.{{Name}}({{Arguments}});
                    result = DataConstants.Unit;
                    {{/IsVoid}}
                    {{^IsVoid}}
                    result = {{#IsAwaitable}}await {{/IsAwaitable}}_instance.{{Name}}({{Arguments}});
                    {{/IsVoid}}
                    break;
                {{/MethodTypeParameters}}
{{/MethodList}}
                default:
                    throw new ArgumentOutOfRangeException("No matching remote method was found.");
            }

            context.Output = Response.ReturnValue(result);

            await next();
        }
    }
}

{{/ClassList}}