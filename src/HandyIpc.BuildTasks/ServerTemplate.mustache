using System;
using HandyIpc;
using HandyIpc.Server;

{{#ClassList}}
namespace {{Namespace}}
{
{{#UsingList}}
using {{.}};
{{/UsingList}}

    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [global::System.Diagnostics.DebuggerNonUserCode]
    [global::System.Reflection.Obfuscation(Exclude = true)]
    public class AutoGeneratedServer{{GeneratedClassSuffix}}{{#TypeParameters}}<{{.}}>{{/TypeParameters}} : IIpcServerProxy
        {{ConstraintClauses}}
    {
        private readonly {{InterfaceName}}{{#TypeParameters}}<{{.}}>{{/TypeParameters}} _instance;

        public AutoGeneratedServer{{GeneratedClassSuffix}}({{InterfaceName}}{{#TypeParameters}}<{{.}}>{{/TypeParameters}} instance)
        {
            _instance = instance;
        }

        public async Task Dispatch(Context context, Func<Task> next)
        {
            var request = context.Get<Request>();
            var args = request.Arguments;

            object result;
            switch (request.MethodName)
            {
{{#MethodList}}
                case "{{Name}}{{#MethodTypeParameters}}<{{.}}>{{/MethodTypeParameters}}({{ParameterTypes}})":
                    {{#IsVoid}}
                    {{#IsAwaitable}}await {{/IsAwaitable}}_instance.{{Name}}({{Arguments}});
                    result = DataConstants.Unit;
                    {{/IsVoid}}
                    {{^IsVoid}}
                    result = {{#IsAwaitable}}await {{/IsAwaitable}}_instance.{{Name}}({{Arguments}});
                    {{/IsVoid}}
                    break;
{{/MethodList}}
                default:
                    throw new ArgumentOutOfRangeException("No matching remote method was found.");
            }

            context.Output = Response.ReturnValue(result);

            await next();
        }
    }
}

{{/ClassList}}