using HandyIpc.Client;
using HandyIpc.Server;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Threading.Tasks;

namespace HandyIpc.Tests
{
    public interface IInterface<T123>
    {
        Task<IEnumerable<string>> GenericMethod<T1, T2>(IDictionary<T123, T1> items1, List<T2> items2);
        void GenericMethod<T1, T2>(IDictionary<T1, T2> items1, List<T2> items2);
        void GenericMethod<T>(IDictionary<T123, T> items1, List<T> items2);
        bool GenericMethod<T1, TT>(string a, T1 b);
    }

    public class Class<T> : IInterface<T>
    {
        async Task<IEnumerable<string>> IInterface<T>.GenericMethod<T1222, TR2>(IDictionary<T, T1222> items1, List<TR2> items2)
        {
            return new List<string> { $"<{typeof(T1222)}, {typeof(TR2)}>" };
        }

        public void GenericMethod<T1, T2>(IDictionary<T1, T2> items1, List<T2> items2)
        {
        }

        public void GenericMethod<T1>(IDictionary<T, T1> items1, List<T1> items2)
        {
        }

        bool IInterface<T>.GenericMethod<T1, TT>(string a, T1 b) => true;
    }

    public class Program
    {
        public static async Task Main(string[] args)
        {
            IInterface<string> a = new Proxy<string>(new Class<string>());
            var mapping = a.GetType()
                .GetInterfaceMap(typeof(IInterface<string>))
                .TargetMethods
                .Where(item => item.IsGenericMethod)
                .ToDictionary(item => item.GetCustomAttribute<IpcMethodAttribute>().Identifier);

            var m = mapping["GenericMethod<T1, T2>(IDictionary<T, T1>, List<T2>)"].MakeGenericMethod(typeof(double), typeof(int));
            var r = m.Invoke(a, new object[] { new Dictionary<string, double>(), new List<int>() });

            var task = (Task<IEnumerable<string>>)r;

            var rr = await task;

            IpcServer.Center
                .Register(typeof(IDemo<>), typeof(Demo<>))
                .Start();

            var demo1 = IpcClient.Of<IDemo<string>>();
            var demo2 = IpcClient.Of<IDemo<int>>();
            var demo3 = IpcClient.Of<IDemo<double>>();

            var r1 = await demo1.GetDefaultAsync();
            var r2 = await demo2.GetDefaultAsync();

            Console.ReadKey();
        }
    }

    public class Proxy<T> : IInterface<T>
    {
        private readonly IInterface<T> _instance;

        public Proxy(IInterface<T> instance)
        {
            _instance = instance;
        }

        [IpcMethod("GenericMethod<T1, T2>(IDictionary<T, T1>, List<T2>)")]
        Task<IEnumerable<string>> IInterface<T>.GenericMethod<T1, T2>(IDictionary<T, T1> items1, List<T2> items2)
        {
            return _instance.GenericMethod<T1, T2>(items1, items2);
        }

        [IpcMethod("GenericMethod<T1, T2>(IDictionary<T1, T2>, List<T2>)")]
        void IInterface<T>.GenericMethod<T1, T2>(IDictionary<T1, T2> items1, List<T2> items2)
        {
            _instance.GenericMethod<T1, T2>(items1, items2);
        }

        [IpcMethod("GenericMethod<T1>(IDictionary<T, T1>, List<T1>)")]
        void IInterface<T>.GenericMethod<T1>(IDictionary<T, T1> items1, List<T1> items2)
        {
            _instance.GenericMethod<T1>(items1, items2);
        }

        [IpcMethod("GenericMethod<T1, TT>(string, T1)")]
        bool IInterface<T>.GenericMethod<T1, TT>(string a, T1 b)
        {
            return _instance.GenericMethod<T1, TT>(a, b);
        }
    }

    public class AutoGeneratedServer<T> : IIpcDispatcher
    {
        private readonly IInterface<T> _instance;
        private readonly Lazy<IReadOnlyDictionary<string, MethodInfo>> _genericMethodMapping;

        public AutoGeneratedServer(IInterface<T> instance)
        {
            _instance = instance;
            _genericMethodMapping = new Lazy<IReadOnlyDictionary<string, MethodInfo>>(
                () => _instance.GetGenericMethodMapping(typeof(IInterface<T>)));
        }

        public async Task Dispatch(Context context, Func<Task> next)
        {
            var request = context.Get<Request>();

            if (request.MethodGenericArguments != null && request.MethodGenericArguments.Any())
            {
                if (_genericMethodMapping.Value.TryGetValue(request.MethodName, out var methodInfo))
                {
                    var constractedGenericMethod = methodInfo.MakeGenericMethod(request.MethodGenericArguments);
                    var obj = constractedGenericMethod.Invoke(_instance, request.Arguments);
                    await (Task)obj;
                }
            }
            else
            {
                switch (request.MethodName)
                {
                    case "GenericMethod<T1, T2>(IEnumerable<T1>, List<T2>)"
                    when _genericMethodMapping.Value.TryGetValue("GenericMethod<T1, T2>(IEnumerable<T1>, List<T2>)", out var methodInfo):
                        break;
                    case "GenericMethod<T1, TT>(string, T1)":

                        break;
                }
            }

            await next();
        }
    }
}
