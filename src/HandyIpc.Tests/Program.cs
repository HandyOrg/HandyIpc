using HandyIpc.Client;
using HandyIpc.Server;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Threading.Tasks;

namespace HandyIpc.Tests
{
    public interface IInterface<T123>
    {
        void GenericMethod<T1, T2>(IDictionary<T123, T1> items1, List<T2> items2);
        void GenericMethod<T1, T2>(IDictionary<T1, T2> items1, List<T2> items2);
        void GenericMethod<T>(IDictionary<T123, T> items1, List<T> items2);
        bool GenericMethod<T1, TT>(string a, T1 b);
    }

    public class Class<T> : IInterface<T>
    {
        void IInterface<T>.GenericMethod<T1222, TR2>(IDictionary<T, T1222> items1, List<TR2> items2)
        {
            var type = $"<{typeof(T1222)}, {typeof(TR2)}>";
        }

        public void GenericMethod<T1, T2>(IDictionary<T1, T2> items1, List<T2> items2)
        {
        }

        public void GenericMethod<T1>(IDictionary<T, T1> items1, List<T1> items2)
        {
        }

        bool IInterface<T>.GenericMethod<T1, TT>(string a, T1 b) => true;
    }

    public class Program
    {
        public static async Task Main(string[] args)
        {
            IInterface<string> a = new Proxy<string>(new Class<string>());
            var mapping = a.GetType()
                .GetInterfaceMap(typeof(IInterface<string>))
                .TargetMethods
                .Where(item => item.IsGenericMethod)
                .ToDictionary(item => item.GetCustomAttribute<IpcMethodAttribute>().Identifier);

            var m = mapping["GenericMethod<T1, T2>(IDictionary<T, T1>, List<T2>)"].MakeGenericMethod(typeof(double), typeof(int));
            m.Invoke(a, new object[] { new Dictionary<string, double>(), new List<int>() });

            IpcServer.Center
                .Register(typeof(IDemo<>), typeof(Demo<>))
                .Start();

            var demo1 = IpcClient.Of<IDemo<string>>();
            var demo2 = IpcClient.Of<IDemo<int>>();
            var demo3 = IpcClient.Of<IDemo<double>>();

            var r1 = await demo1.GetDefaultAsync();
            var r2 = await demo2.GetDefaultAsync();
            var r3 = await demo3.GetDefaultAsync();

            Console.ReadKey();
        }
    }

    public class Proxy<T> : IInterface<T>
    {
        private readonly IInterface<T> _instance;

        public Proxy(IInterface<T> instance)
        {
            _instance = instance;
        }

        [IpcMethod("GenericMethod<T1, T2>(IDictionary<T, T1>, List<T2>)")]
        void IInterface<T>.GenericMethod<T1, T2>(IDictionary<T, T1> items1, List<T2> items2)
        {
            _instance.GenericMethod<T1, T2>(items1, items2);
        }

        [IpcMethod("GenericMethod<T1, T2>(IDictionary<T1, T2>, List<T2>)")]
        void IInterface<T>.GenericMethod<T1, T2>(IDictionary<T1, T2> items1, List<T2> items2)
        {
            _instance.GenericMethod<T1, T2>(items1, items2);
        }

        [IpcMethod("GenericMethod<T1>(IDictionary<T, T1>, List<T1>)")]
        void IInterface<T>.GenericMethod<T1>(IDictionary<T, T1> items1, List<T1> items2)
        {
            _instance.GenericMethod<T1>(items1, items2);
        }

        [IpcMethod("GenericMethod<T1, TT>(string, T1)")]
        bool IInterface<T>.GenericMethod<T1, TT>(string a, T1 b)
        {
            return _instance.GenericMethod<T1, TT>(a, b);
        }
    }

    public class AutoGeneratedServer<T> : IIpcServerProxy
    {
        private readonly IInterface<T> _instance;
        private readonly IReadOnlyDictionary<MethodSignature, MethodInfo> _genericMethodMapping;

        public AutoGeneratedServer(IInterface<T> instance)
        {
            _instance = instance;
            _genericMethodMapping = _instance.GetType()
                .GetInterfaceMap(typeof(IInterface<T>))
                .TargetMethods
                .Where(item => item.IsGenericMethod)
                .ToDictionary(MethodSignature.FromMethodInfo);
        }


        public IReadOnlyDictionary<MethodSignature, MethodInfo> Mapping => _genericMethodMapping;

        public async Task Dispatch(Context context, Func<Task> next)
        {
            var request = context.Get<Request>();

            switch (request.MethodName)
            {
                case "GenericMethod<T1, T2>(IEnumerable<T1>, List<T2>)":

                    break;
                case "GenericMethod<T1, TT>(string, T1)":

                    break;
            }

            await next();
        }
    }
}
