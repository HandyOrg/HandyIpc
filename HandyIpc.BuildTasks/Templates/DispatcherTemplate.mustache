//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by HandyIpc.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using HandyIpc;
using HandyIpc.Server;

{{#ClassList}}
namespace {{Namespace}}
{
    {{#UsingList}}
    using {{.}};
    {{/UsingList}}

    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [global::System.Diagnostics.DebuggerNonUserCode]
    [global::System.Reflection.Obfuscation(Exclude = true)]
    public class HandyIpcDispatcher{{GeneratedClassSuffix}}{{#TypeParameters}}<{{.}}>{{/TypeParameters}} : IIpcDispatcher
        {{ConstraintClauses}}
    {
        private readonly {{InterfaceName}}{{#TypeParameters}}<{{.}}>{{/TypeParameters}} _instance;
{{#HasGenericMethod}}
        private readonly Lazy<IReadOnlyDictionary<string, MethodInfo>> _genericMethodMapping;
{{/HasGenericMethod}}

        public HandyIpcDispatcher{{GeneratedClassSuffix}}({{InterfaceName}}{{#TypeParameters}}<{{.}}>{{/TypeParameters}} instance)
        {
            _instance = instance;
{{#HasGenericMethod}}
            _genericMethodMapping = new Lazy<IReadOnlyDictionary<string, MethodInfo>>(
                () => _instance.GetGenericMethodMapping(typeof({{InterfaceName}}{{#TypeParameters}}<{{.}}>{{/TypeParameters}})));
{{/HasGenericMethod}}
        }

        public async Task Dispatch(Context ctx, Func<Task> next)
        {
            var request = ctx.Request;
            if (request is null)
            {
                throw new InvalidOperationException($"The {nameof(Context.Request)} must be parsed from {nameof(Context.Input)} before it can be used.");
            }

            switch (request.MethodName)
            {
{{#MethodList}}
                {{#MethodTypeParameters}}
                case "{{Name}}<{{.}}>({{ParameterTypes}})"
                when (_genericMethodMapping.Value.TryGetValue("{{Name}}<{{.}}>({{ParameterTypes}})", out var methodInfo)):
                {
                    var args = Signals.GetArguments(ctx.Input, request.ArgumentTypes, ctx.Serializer.Deserialize);
                    var constructedMethodInfo = methodInfo.MakeGenericMethod(request.MethodGenericArguments);
                    var obj = constructedMethodInfo.Invoke(_instance, args);
                    {{#IsVoid}}
                    {{#IsAwaitable}}await (Task)obj;{{/IsAwaitable}}
                    ctx.Output = Signals.Unit;
                    {{/IsVoid}}
                    {{^IsVoid}}
                    {{#TaskReturnTypeContainsGenericParameter}}
                    var result = await constructedMethodInfo.ReturnType.UnpackTask(obj);
                    ctx.Output = Signals.GetResponseValue(result, constructedMethodInfo.ReturnType, ctx.Serializer.Serialize);
                    {{/TaskReturnTypeContainsGenericParameter}}
                    {{^TaskReturnTypeContainsGenericParameter}}
                    var result = {{#IsAwaitable}}await ({{ReturnType}}){{/IsAwaitable}}obj;
                    ctx.Output = Signals.GetResponseValue(result, constructedMethodInfo.ReturnType, ctx.Serializer.Serialize);
                    {{/TaskReturnTypeContainsGenericParameter}}
                    {{/IsVoid}}
                    break;
                }
                {{/MethodTypeParameters}}
                {{^MethodTypeParameters}}
                case "{{Name}}({{ParameterTypes}})":
                {
                    var args = Signals.GetArguments(ctx.Input, new Type[] { {{MethodParameterTypes}} }, ctx.Serializer.Deserialize);
                    {{#IsVoid}}
                    {{#IsAwaitable}}await {{/IsAwaitable}}_instance.{{Name}}({{Arguments}});
                    ctx.Output = Signals.Unit;
                    {{/IsVoid}}
                    {{^IsVoid}}
                    var result = {{#IsAwaitable}}await {{/IsAwaitable}}_instance.{{Name}}({{Arguments}});
                    ctx.Output = Signals.GetResponseValue(result, typeof({{ReturnType}}), ctx.Serializer.Serialize);
                    {{/IsVoid}}
                    break;
                }
                {{/MethodTypeParameters}}
{{/MethodList}}
                default:
                    throw new ArgumentOutOfRangeException("No matching remote method was found.");
            }

            await next();
        }
    }
}

{{/ClassList}}
