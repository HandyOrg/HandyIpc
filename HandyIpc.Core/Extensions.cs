using System;
using System.Linq;
using System.Security.Cryptography;
using System.Text;

namespace HandyIpc
{
    public static class Extensions
    {
        public static IServerRegistry Register<TInterface, TImpl>(this IServerRegistry registry, string? key = null)
            where TInterface : class
            where TImpl : TInterface, new()
        {
            return registry.Register<TInterface>(() => new TImpl(), key);
        }

        public static IServerRegistry Register<TInterface>(this IServerRegistry registry, Func<TInterface> factory, string? key = null)
            where TInterface : class
        {
            key ??= typeof(TInterface).GetDefaultKey();
            return registry.Register(typeof(TInterface), factory, key);
        }

        public static IServerRegistry Register(this IServerRegistry registry, Type interfaceType, Type classType, string? key = null)
        {
            key ??= interfaceType.GetDefaultKey();
            return classType.ContainsGenericParameters
                ? registry.Register(interfaceType, GenericFactory, key)
                : registry.Register(interfaceType, () => Activator.CreateInstance(classType), key);

            // Local Method
            object GenericFactory(Type[] genericTypes)
            {
                var constructedClassType = classType.MakeGenericType(genericTypes);
                return Activator.CreateInstance(constructedClassType);
            }
        }

        public static T Resolve<T>(this IClient client) => client.Resolve<T>(typeof(T).GetDefaultKey());

        internal static string GetDefaultKey(this Type interfaceType)
        {
            if (interfaceType.IsGenericType)
            {
                interfaceType = interfaceType.GetGenericTypeDefinition();
            }

            using var sha256 = new SHA256CryptoServiceProvider();
            byte[] buffer = Encoding.UTF8.GetBytes(interfaceType.AssemblyQualifiedName!);
            byte[] sha256Bytes = sha256.ComputeHash(buffer);

            return string.Concat(sha256Bytes.Select(item => item.ToString("x")));
        }

        internal static Type GetClientType(this Type interfaceType)
        {
            return GetAutoGeneratedType(interfaceType, "ClientProxy");
        }

        internal static Type GetDispatcherType(this Type interfaceType)
        {
            return GetAutoGeneratedType(interfaceType, "Dispatcher");
        }

        internal static Type GetServerProxyType(this Type interfaceType)
        {
            return GetAutoGeneratedType(interfaceType, "ServerProxy");
        }

        private static Type GetAutoGeneratedType(Type interfaceType, string category)
        {
            string typeName;
            string prefix = category;

            if (interfaceType.IsNested)
            {
                string className = $"{prefix}{interfaceType.DeclaringType!.Name}{interfaceType.Name}";
                typeName = interfaceType.AssemblyQualifiedName!.Replace(
                    $"{interfaceType.DeclaringType.FullName}+{interfaceType.Name}",
                    $"{interfaceType.Namespace}.{className}");
            }
            else
            {
                string className = $"{prefix}{interfaceType.Name}";

                if (interfaceType.Namespace == null)
                {
                    className = $"{className}.{className}";
                }

                typeName = interfaceType.AssemblyQualifiedName!.Replace(interfaceType.Name, className);
            }

            return Type.GetType(typeName) ??
                   throw new InvalidOperationException($"{interfaceType.Name} doesn't look like a Ipc interface. ");
        }
    }
}
